- ### `x86 아키텍쳐`는 왜 레지스터를 아껴 써야 하는가?
	`x86 아키텍쳐`라 함은 관습적으로 `x86-64` 이전의 아키텍쳐를 말하며 `x86-16`과 `x86-32`기준으로 14개의 레지스터를 갖고 있으며 이 중 범용 레지스터의 수는 4개이다. `x86 아키텍쳐`의 레지스터 용량 문제도 생각해보았을 때 그렇다면 왜 레지스터의 개수를 늘리지 않았을까?라는 의문이 든다.  
	이후의 `AMD64 아키텍쳐`에서 레지스터의 개수와 용량을 늘려 문제점을 해결한 것을 비추어 보았을 때 그 시대 당시의 CPU 설계자들의 기술적 한계점과 레지스터 개수를 늘리면 발생하는 가격간에 trade off를 고려한 것이 아닌가 생각된다.

	> 레지스터의 용량과 개수가 적은 것은 시대 당시 기술적 한계와 비용 문제
	
- ### __프로세스__ 와 __스레드__ 의 차이는 무엇인가?
	
	- #### __프로세스__
		프로그램 하나가 실행될 때 쓰이는 단위
		- 운영체제로 부터 메모리를 할당받으며 스케줄링의 대상이 된다.
	- #### __스레드__
		프로세스 안의 작은 작업 단위
		- 최소 하나 이상이 존재하며 프로세스의 메모리 자원을 공유
	
	- #### `리눅스`에서의 __스레드__
		다른 프로세스와 자원을 공유하는 경량화된 프로세스
		
	- #### `리눅스`에서 __스레드__ 개념을 별도로 정의하지 않고, 단지 *자원을 공유하는 프로세스* 의 형태로 구현하는 이유는 무엇인가?
		`리눅스`에서의 __스레드__ 는 __프로세스__ 와 크게 다르지 않다. 단지 차이점은 *자원을 공유* 한다는 점이다.  
		
		- `리눅스`에서 프로세스 생성 시에 `fork()` 와 `exec()` 으로 관리를 한다. __스레드__ 개념이 도입 되었을 때 굳이 __프로세스__ 와 구분해서 별도의 개념을 취급하기 보다는 __스레드__ 생성 시에는 별도의 플래그를 지정하여  사용할 수 있게 하였다.
		
		> 이 때 공유되는 자원은 `주소 공간`, `파일시스템 자원`, `파일 서술자`, `시그널 핸들러`이다.
		
- ### 커널이 __부모프로세스__ 보다 __자식프로세스__ 를 의도적으로 먼저 실행해야 하는 이유는 무엇인가?
	`리눅스`에서는 __Copy-on-Write__ 기능을 제공한다. 관습적으로 __자식프로세스__ 는 fork() 뒤에 바로 exec()을 하기에 __copy-on-write__ 를 수행하지 않겠지만 __부모프로세스__ 는 fork() 뒤에 어떤 동작이 올 지 모르며 쓰기 동작을 수행 시 __자식프로세스__ 와 공유하는 페이지만큼의 공간을 확보 후 확보된 공간에 쓰기를 수행하기에 overhead가 발생하게 된다.  
		
	- #### 왜 아직까지 제대로 동작하지 않는가?
		`리눅스`의 프로세스 계층 특성상 모든 프로세스가 __부모프로세스__ __자식프로세스__ 관계를 갖는다. __자식프로세스__ 에게 우선순위를 부여해 주면 최악의 상황에서 __부모프로세스__ 는 계속 우선순위가 밀려 실행되지 않는 상황이 발생가능하다. 이 상황에서만 __자식프로세스__ 에게 우선순위를 부여하려면 갓 fork()된 __자식프로세스__ 에게 우선순위를 부여해야 되는 것인데 기술적으로 아직 구현이 안되는 것이 아닌가 유추해 본다.
		
- ### __CFS 스케줄러__ 는 __O(1) 스케줄러__ 의 어떤 문제점을 해결하였으며, __CFS 스케줄러__ 가 가지는 한계는 무엇인가?

	- #### __O(1) 스케줄러__ 의 문제점(부작용)
		1. __나이스__ 값에 따라 __타임슬라이스__ 를 고정 할당하기에 작업전환 최적화가 어렵다.
			- __나이스 값__ 이 0인 두 개의 프로세스가 존재할 때 100ms의 __타임슬라이스__ 를 할당하게 되며 작업전환이 100ms마다 일어나게 되어 효과적인 __타임슬라이스__ 할당이라고 볼 수 없다.
			- __나이스 값__ 이 20인 두 개의 프로세스가 존재할 때 5ms의 __타임슬라이스__ 를 할당받아 작업전환이 너무 빈번히 일어나 문맥전환 비용이 너무 많이 발생하게 된다.
		
		2. 	__나이스__ 값에 따라 __타임슬라이스__ 의 상대적인 차이가 발생한다.
			- __나이스__ 값이 0과 1인 경우와 19 20인 경우를 생각해보면 __타임슬라이스__ 의 비율이 각각 100:95 와 10:5 이다. 각각 __나이스 값__ 에선 단지 1의 차이를 보이지만 비율은 후자가 2배나 차이나게 된다.
			
		3. `운영체제`마다 __타임슬라이스__ 의 길이가 달라질 수 있다.
			- __나이스 값__ 에 따라 __타임슬라이스__ 의 절대값을 할당할 수 있어야 하며 이는 커널이 측정할 수 있는 단위로 정해져야 한다. 그렇기에 `운영체제`의 타이머 클럭의 일정 배수로 __타임슬라이스__ 단위를 정하게 되는데 `운영체제`마다 타이머 틱 값이 다르기에 문제점이 발생하게 된다.
			
		4. 	우선순위 기반 __스케줄러__ 가 대화형 작업 최적화 시 불공정 할당 문제가 발생한다.
			- 대화형 프로세스가 할당받은 __타임슬라이스__ 를 모두 소진 후 잠들어 있을 때 키보드 입력 등의 `인터럽트`가 발생하여 대화형 프로세스를 깨우는 상황이 일어나면 대화형 성능을 향상시킬 수 있겠으나, 나머지 시스템을 희생시켜 한 프로세스에게만 불공정하게 프로세서를 할당하게되는 허점이 발생한다.
			
	- #### __CFS 스케줄러__ 의 스케줄링
		- 프로세스에 할당할 프로세서 시간 비율의 가중치로 __나이스 값__ 을 사용한다. 
			__나이스 값__ 이 높을 수록 낮은 비율의 가중치를 낮을 수록 높은 비율의 가중치를 받으며 __O(1) 스케줄러__ 의 __타임슬라이스__ 상대적 차이를 해결할 수 있다.
		
		- `완전 멀티태스킹`의 무한히 작은 스케줄링 단위를 근사한 __목표 응답시간__ 을 설정한다.
			이 시간안에 모든 프로세스가 1번씩 실행되게 하며 이 시간이 짧을 수록 대화형 성능이 좋아지게 된다. __목표 응답시간__ 을 도입해 __O(1) 스케줄러__ 의 문제점인 __타임슬라이스__ 고정 할당 문제, `운영체제`마다 __타임슬라이스__가 다른 문제와 대화형 최적화 시 불공정 할당 문제를 해결하였다.
		
	- #### __CFS 스케줄러__ 의 한계점
		- 실행 중인 프로세스가 많아지면 받아들일 수 없는 수준의 전환 비용이 발생한다.
			프로세스가 많아지면 그만큼 타임슬라이스가 작아지게 되며 타임슬라이스가 너무 작아지게 되면 문맥 전환 비용이 커지기에 __최소 세밀도__ 인 1ms 이하로는 쪼개 질 수 없게 하였다. 
			
			> __목표 응답시간__ 이 20ms 일 때 프로세스가 100개가 되면 어떻게 되는가?
		
	- #### `리눅스`가 두 가지 별개의 우선순위 단위 *(나이스 값, 실시간 우선순위)* 를 가지는 이유는 무엇인가?
		효과적인 스케줄링을 위해 도입한 개념으로 생각되며 __나이스 값__ 만으로는 대화형과 같은 프로세스의 우선순위를 계산하기 어려우며 실시간 우선순위 만으로는 대화형 프로세스에게만 큰 우선순위를 부여하면 불공정 스케줄링 문제점을 보완하기 위해 두 가지의 우선순위 단위를 사용한 것이라 생각한다.
	