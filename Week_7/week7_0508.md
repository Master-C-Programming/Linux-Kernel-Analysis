- ### `시스템 타이머`의 `진동수`가 높을 때와 낮을 때의 장단점을 각각 기술하시오.
    - 진동수(HZ): 1초에 jiffies가 업데이트되는 횟수
    
    - 높을 때
        - 장점
            1. 타이머가 더 자주 울리므로 정확도 향상
            2. 타임아웃 값을 선택적으로 사용할 수 있는 `poll()`이나 `select()` 같은 시스템 호출의 정밀도 향상
            3. 프로세스 선점 정확도 향상
            4. 자원 사용률 및 시스템 가동 시간 등의 세밀한 측정 가능
        
        - 단점
            1. 부가 비용의 증가
                - 타이머 인터럽트가 더 자주 발생하여 프로세서가 타이머 인터럽트 처리에 드는 총 시간 증가
                - 프로세서 캐시 정보가 더 자주 손실
                - 전력 소모 증가

    - 낮을 때
        - 장점
            1. 부가 비용의 감소
                - 프로세서가 타이머 인터럽트 처리에 드는 시간 감소
                - `Context Switch` 주기가 길어져 프로세서 캐시 정보 보존률 증가
                - 전력 소모 감소
        
        - 단점
            1. `poll()`이나 `select()` 같은 시스템 호출의 정밀도 감소
            2. 스케줄링 지연 발생 가능성이 높음
            3. 자원 사용률 및 시스템 가동시간 등과 같은 측정값들의 정확도 감소

- ### `타이머 인터럽트 핸들러`의 동작 과정을 서술하시오.
    - `타이머 인터럽트 핸들러`는 __아키텍처 종속적인 부분__ 과 __아키텍처 독립적인 부분__ 으로 나눌 수 있다. __아키텍처 독립적인 부분__ 은 대부분 아키텍처의 `타이머 인터럽트 핸들러`가 수행하는 최소한의 작업을 처리하는 부분이고, __아키텍처 종속적인 부분__ 은 아키텍처에 따라 작업 내용이 달라질 수 있는 부분이다.
    - __아키텍처 독립적인 부분__
        - `jiffies_64` 및 `xtime`변수에 안전하게 접근하기 위해 `xtime_lock`을 얻는다.
            - 공유 변수에 하나의 스레드만 접근할 수 있도록 하기 위한 것과 더불어, 32비트 컴퓨터에서는 64비트 값에 원자적으로 접근할 수 없어서 락을 얻기도 한다.
        - 필요에 따라 시스템 타이머를 확인하고 재설정한다.
        - `x86`같은 일부 아키텍처는 주기적으로 갱신되는 `xtime`값을 `RTC`값에 반영한다.  
        - 아키텍처 종속적 타이머 함수인 `tick_periodic()`함수를 호출한다.

    - `tick_periodic()`함수의 __아키텍처 종속적인 부분__
        - `tick_periodic()`함수의 대부분의 중요한 작업은 `do_timer()`함수와 `update_process_times()`함수에서 처리한다.
        - `do_timer()`
            - `jiffies_64`값 1 증가
                - 락을 얻었기 때문에 32비트 컴퓨터에서도 안전하게 이 작업을 처리할 수 있다.
            - `update_wall_time()`함수가 `xtime`에 저장된 현재 시간을 갱신한다.
            - `calc_global_load()`함수가 시스템의 평균 로드 통계를 갱신한다.
            - `do_timer()`함수가 반환되면 `update_process_times()`함수를 호출한다.
        - `update_process_times()`
            - `account_process_tick()`함수는 현재 실행 중인 프로세스가 소모한 자원 사용 통계값을 갱신한다.
                - 실제로 하나의 타이머 틱 동안 여러 프로세스가 실행되었을 수도 있지만, 커널은 타이머 인터럽트가 발생한 시점에 실행되고 있는 프로세스만이 해당 타이머 틱을 독점한 것으로 간주한다.
            - `run_local_timers()`함수는 `softirq`를 발생시켜서 설정 시간이 지난 동적 타이머를 실행한다.
            - `schedule_tick()`함수는 현재 실행 중인 프로세스의 타임슬라이스 값을 줄이고, 필요한 경우 `need_sched`플래그를 설정한다.
        - 이후 `tick_periodic()`함수는 처음의 아키텍처 독립적인 핸들러 함수로 반환되고, 필요한 정리 작업을 수행한 후 `xtime_lock`을 풀고 반환한다.

- ### `실행 지연` 해결책들의 특징과 장단점에 대해 논하시오.
	- #### __루프 반복__
		- 정밀도가 중요하지 않을 때 사용한다.
		- 원하는 클럭 진동수가 지날 때까지 루프를 반복한다.
			- 장점
				- 단순하게 `jiffies` 값이 `timeout` 값을 초과했는지 검사하며 루프를 돌기에 가장 구현이 간단하다.
			- 단점
				- 실행 지연을 하는 동안 프로세서가 무의미한 루프를 돌게되며, 유용한 작업을 수행하지 못한다.
				- 다른 프로세스에 의해 선점이 가능한 상황에서는 `jiffies` 값이 원하는 `timeout` 값을 초과하여 원하는 시간 지연을 얻지 못할 수 있다. 
	
	- #### __작은 지연__
		- 나노초, 마이크로초, 밀리초와 같이 원하는 실행 지연 시간이 __클럭 주기__ 보다 짧은 경우 `ndelay()`, `udelay()`, `mdelay()` 의 세 가지 함수를 사용하여 지연 처리를 한다.
		- 루프를 1회 돌 때 걸리는 정확한 시간을 이용해 실행 지연을 수행한다.
			- 장점
				- 정밀도가 높아 세밀한 지연 시간을 얻을 수 있다.
			- 단점
				- 매우 작은 시간에서만 사용해야 하며 큰 값을 사용한다면 `udelay()` 와 같은 함수에서 사용하는 단위가 매우 작기에 쉽게 __overflow__ 현상이 발생할 수 있다.
	
	- #### __schedule_timeout()__
		- `add_timer()` 함수를 사용해 지정한 시간을 설정하고 __휴면 상태__로 전환한다.
		- 휴면이 가능해야 하기에 프로세스 컨텍스트에서 잠금을 설정하지 않은 상태에서만 사용할 수 있다.
			- 장점
				- 실행 지연을 수행하는 동안 CPU를 무의미하게 소모하지 않고 휴면 상태에 들어가 CPU 이용률을 높여준다.
			- 단점 
				- 최소한 `add_timer()` 함수에 지정한 시간이 지나야 깨워져 실행 대기열에 들어가기에 정확히 원하는 지연 시간을 얻지 못할 수 있다.
	
- ### `schedule_timeout()`은 `작은 지연`에서도 `udelay`, `mdelay`보다 더 나은 해결책인가?
	- 지연 시간이 상당히 작은 상황에서는 `schedule_timeout()` 의 대기전환, 깨우기 비용이 지연 시간을 초과할 수 있기에 `작은 지연` 에서는 `udelay()`, `mdelay()` 함수를 사용하는 것이 성능상 이점이 있을 것이다.

