- ### `시스템 타이머`의 `진동수`가 높을 때와 낮을 때의 장단점을 각각 기술하시오.

- ### `타이머 인터럽트 핸들러`의 동작 과정을 서술하시오.
    - `타이머 인터럽트 핸들러`는 __아키텍처 종속적인 부분__ 과 __아키텍처 독립적인 부분__ 으로 나눌 수 있다. __아키텍처 독립적인 부분__ 은 대부분 아키텍처의 `타이머 인터럽트 핸들러`가 수행하는 최소한의 작업을 처리하는 부분이고, __아키텍처 종속적인 부분__ 은 아키텍처에 따라 작업 내용이 달라질 수 있는 부분이다.
    - __아키텍처 독립적인 부분__
        - `jiffies_64` 및 `xtime`변수에 안전하게 접근하기 위해 `xtime_lock`을 얻는다.
            - 공유 변수에 하나의 스레드만 접근할 수 있도록 하기 위한 것과 더불어, 32비트 컴퓨터에서는 64비트 값에 원자적으로 접근할 수 없어서 락을 얻기도 한다.
        - 필요에 따라 시스템 타이머를 확인하고 재설정한다.
        - 갱신된 현재 시간(`xtime`)을 주기적으로 실시간 시계(`RTC`)에 반영한다.
            - `RTC`값을 이용해서 `xtime`값을 초기화하는 것은 시스템 부팅 시에만 일어난다. 즉 커널은 한번 `RTC`값을 얻은 후로는 `RTC`에 접근하는 일이 없다. 따라서 주기적으로 갱신되는 `xtime`값을 `RTC`값에 반영해주는 것이다. 
        - 아키텍처 종속적 타이머 함수인 `tick_periodic()`함수를 호출한다.

    - `tick_periodic()`함수의 __아키텍처 종속적인 부분__
        - `tick_periodic()`함수의 대부분의 중요한 작업은 `do_timer()`함수와 `update_process_times()`함수에서 처리한다.
        - `do_timer()`
            - `jiffies_64`값 1 증가
                - 락을 얻었기 때문에 32비트 컴퓨터에서도 안전하게 이 작업을 처리할 수 있다.
            - `update_wall_time()`함수가 `xtime`에 저장된 현재 시간을 갱신한다.
            - `calc_global_load()`함수가 시스템의 평균 로드 통계를 갱신한다.
            - `do_timer()`함수가 반환되면 `update_process_times()`함수를 호출한다.
        - `update_process_times()`
            - `account_process_tick()`함수는 현재 실행 중인 프로세스가 소모한 자원 사용 통계값을 갱신한다.
                - 실제로 하나의 타이머 틱 동안 여러 프로세스가 실행되었을 수도 있지만, 커널은 타이머 인터럽트가 발생한 시점에 실행되고 있는 프로세스만이 해당 타이머 틱을 독점한 것으로 간주한다.
            - `run_local_timers()`함수는 `softirq`를 발생시켜서 설정 시간이 지난 동적 타이머를 실행한다.
            - `schedule_tick()`함수는 현재 실행 중인 프로세스의 타임슬라이스 값을 줄이고, 필요한 경우 `need_sched`플래그를 설정한다.
        - 이후 `tick_periodic()`함수는 처음의 아키텍처 독립적인 핸들러 함수로 반환되고, 필요한 정리 작업을 수행한 후 `xtime_lock`을 풀고 반환한다.

- ### `실행 지연` 해결책들의 특징과 장단점에 대해 논하시오.

- ### `schedule_timeout()`은 `작은 지연`에서도 `udelay`, `mdelay`보다 더 나은 해결책인가?