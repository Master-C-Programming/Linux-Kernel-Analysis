- ### `커널 디버깅`과 `사용자 공간 애플리케이션 디버깅`이 무엇이 다른지 논하시오.
	- `사용자 공간 애플리케이션`의 디버깅
		1. 직접적인 __예외__ 를 던지고 강제 종료되는 경우가 많다.
		2. `디버깅`을 위해 콘솔 출력을 부담없이 사용할 수 있다.
		3. 시스템에 치명적일 확률이 `커널 버그` 보다 상대적으로 적다.
		
	- `커널` 디버깅 과 `사용자 공간 애플리케이션`의 디버깅 비교
		1. `커널`의 버그는 명확하지 않다.
			- 발생 확률이 낮은 경쟁 상황
			- 상황과 환경에 따라 달라지는 성능
			- 특정 조건에서만 발생하는 버그
		2. `커널`에 콘솔 출력은 제한적이다.
			- 커널 함수 중에는 일 초에 여러 번 호출 되는 경우도 있기에 __출력 오버플로우__ 를 고려해야 한다. 이를 해결하기 위해 출력 빈도와 출력 횟수 제한을 고려해야 할 것이다. 
			- 시스템 부팅 전에는 콘솔 출력을 할 수 없다. 이를 해결하기 위해 `early_printk()` 를 사용하거나 하드웨어를 사용해 외부로 통신하는 방법을 사용할 수 있다.
		3. `커널`의 버그는 시스템에 치명적일 확률이 크다.
			- `커널`이 높은 수준의 버그를 내면 시스템 전체가 망가지는 리스크를 안고 있다.
		
- ### `printf()`와 `printk()`의 차이점에 대해 논하시오.


- ### `디버거`는 어떻게 `디버깅`을 하는가?
    1. `디버거`는 사용자에 의해 `breakpoint`로 지정된 명령어의 첫번째 바이트(OP code) 값을 `CC`(int 3)로 변경한다.
    2. `디버깅`의 대상인 프로세스가 사용자가 지정한 `breakpoint`에 도달하면 `CPU`는 `int 3` 예외를 던진다.
    3. 운영체제는 `int 3` 예외를 받고 현재 프로세스가 `디버깅` 되고 있음을 알아챈다.
    4. 그 후 운영체제는 `디버거`에게 `breakpoint`에 도달했음을 알린다.
    5. `breakpoint`에 도착하여 프로세스가 중단되고 난 후, `디버거`는 `CC`로 변경되었던 첫번째 바이트 값을 원래대로 돌려놓는다.
    6. `디버거`는 `Trap Flag`를 설정하고, 프로세스를 재개한다.
    7. `TF`는 `CPU`가 `single-step mode`로 동작할 수 있게 해준다.
    8. 1-7을 반복한다.

- ### `ksymoops`의 탄생과 작동 방법에 대해 논하시오.
    - `oops`는 스스로 문제를 해결하거나 종료하는 방법으로 버그를 처리할 수 없는 __전체 시스템 관리자인 `커널`__ 이 콘솔 출력, 역추적 정보 제공 등으로 버그를 알리는 방법이다.
    - `oops`는 __미해석 상태__ 일 때는 메모리 주소가 그 주소에 해당하는 함수로 변환되어 출력되지 않는다. 
    - `ksymoops`는 __미해석 상태__ 인 `oops`를 __해석 상태__ 로 변환해준다. 다음 명령어를 실행하면 된다.
        > ksymoops saved_oops.txt