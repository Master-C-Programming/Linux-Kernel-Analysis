- ### 각 프로세스에 할당되는 `timeslice`는 `timer tick`에 의존적인데, 프로세스의 실제 실행 시간을 기록하는 `vruntime`이 어떻게 `timer tick`으로부터 독립적이라고 말할 수 있는가?

    - #### vruntime 구하는 공식
        - vruntime = vruntime + runtime × 1024/load weight
    
    - 기존의 O(1) timeslice는 timer tick에 의존해왔으며 이러한 문제를 해결하기 위해 CFS스케줄러가 등장했다. 이 CFS스케줄러의 단위는 vruntime으로 나노초(ns)를 사용한다. 위의 공식을 참고하면 vruntime은 timer tick과는 달리 runtime이 실제 걸린 시간을 기준으로 하기 때문에 결과적으로 독립적이라고 말할 수 있는 것이다.

- ### 사용자 애플리케이션이 `시스템 호출`을 사용하는 일련의 과정을 `구체적인 동작`과 `그 동작을 수행하는 주체`를 명시하여 자세히 설명하시오.

    

- ### `시스템 호출`을 직접 구현하는 것이 권장되지 않는 이유는 무엇인가?
    __시스템 호출__ 을 구현할 경우 공식적으로 할당 된 __시스콜 번호__ 를 필요로 하며 __아키텍처__별로 __시스템 호출__ 을 따로 등록하고 지원을 해야한다. 하지만 생긴지 얼마 되지 않은 시스템 호출에 대해 glibc에서 지원을 하기에는 무리가 있다. 또한 새로 구현된 시스템 호출은 기존의 것들과 호환성이나 안정성이 보장되지 않으므로 새로 구현하는 것보다 기존의 것들을 수정하고 발전해 나아가는 것이 권장된다. 


- ### `커널 공간`과 `사용자 공간`에 대해 논하시오.
    운영체제의 핵심 기능을 수행하는 코드가 있는 공간을 커널 공간이라고 하고 사용자 공간은 모든 사용자 모드 응용 프로그램들이 동작하는 영역이다. 사용자 공간에서 실행되는 프로세스는 커널 공간에 엑세스 불가능하다. 사용자 공간 프로세스가 커널 공간에 접근하기 위해서는 인터럽트를 통해 모드를 변경한다.