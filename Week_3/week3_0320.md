- ### 각 프로세스에 할당되는 `timeslice`는 `timer tick`에 의존적인데, 프로세스의 실제 실행 시간을 기록하는 `vruntime`이 어떻게 `timer tick`으로부터 독립적이라고 말할 수 있는가?

    - #### vruntime 구하는 공식
        - vruntime = vruntime + runtime × 1024/load weight
    
    - 기존의 O(1) timeslice는 timer tick에 의존해왔으며 이러한 문제를 해결하기 위해 CFS스케줄러가 등장했다. 이 CFS스케줄러의 단위는 vruntime으로 나노초(ns)를 사용한다. 위의 공식을 참고하면 vruntime은 timer tick과는 달리 runtime이 실제 걸린 시간을 기준으로 하기 때문에 결과적으로 독립적이라고 말할 수 있는 것이다.

- ### 사용자 애플리케이션이 `시스템 호출`을 사용하는 일련의 과정을 `구체적인 동작`과 `그 동작을 수행하는 주체`를 명시하여 자세히 설명하시오.
    1. 응용프로그램이 C 라이브러리의 래퍼함수에 시스템 호출에 필요한 인자를 스택을 통해 제공
    2. C라이브러리의 래퍼함수는 스택에 있는 인자들을 레지스터로 복사
    3. C라이브러리의 래퍼함수는 시스템 호출 번호를 특정 레지스터에 복사
    4. C라이브러리는 트랩 기계어 명령을 실행하고 이는 프로세서를 커널모드로 전환한 후 커널의 트랩벡터 0X80이 가리키는 코드 실행
    5. 시스템은 0X80트랩을 처리하기 위해 System call() 루틴을 호출
    6. System call() 루틴은 레지스터 값들을 커널 스택에 저장하고 시스템 호출 번호가 유효한지 확인하여 적절한 시스템 호출 서비스 루틴 호출
    7. 시스템 호출 서비스 루틴이 필요한 작업 수행 후 결과를 System call() 루틴에 return
    8. 커널 스택에서 레지스터 값들을 복원하고 시스템 호출 리턴값을 스택에 저장
    9. C라이브러리의 래퍼함수로 돌아오면서 프로세서도 사용자 모드로 전환
    

- ### `시스템 호출`을 직접 구현하는 것이 권장되지 않는 이유는 무엇인가?
    __시스템 호출__ 을 구현할 경우 공식적으로 할당 된 __시스콜 번호__ 를 필요로 하며 __아키텍처__별로 __시스템 호출__ 을 따로 등록하고 지원을 해야한다. 하지만 생긴지 얼마 되지 않은 시스템 호출에 대해 glibc에서 지원을 하기에는 무리가 있다. 또한 새로 구현된 시스템 호출은 기존의 것들과 호환성이나 안정성이 보장되지 않으므로 새로 구현하는 것보다 기존의 것들을 수정하고 발전해 나아가는 것이 권장된다. 


- ### `커널 공간`과 `사용자 공간`에 대해 논하시오.
    운영체제의 핵심 기능을 수행하는 코드가 있는 공간을 커널 공간이라고 하고 사용자 공간은 모든 사용자 모드 응용 프로그램들이 동작하는 영역이다. 사용자 공간에서 실행되는 프로세스는 커널 공간에 엑세스 불가능하다. 사용자 공간 프로세스가 커널 공간에 접근하기 위해서는 인터럽트를 통해 모드를 변경한다.