- ### `리눅스`의 `low memory`와 `high memory`에 대해 설명하시오.
	- #### __low memory__
		- __커널 공간__ 의 메모리 영역이다.
		- `32비트 시스템`에서 __4GB__ 주소 공간 중 보통 *0xc0000000 - 0xffffffff* 주소 구간에 해당한다.
		
	- #### __high memory__
		- __사용자 공간__ 의 메모리 영역이다.
		- `32비트 시스템`에서 보통 *0x00000000 - 0xbfffffff* 주소 구간에 해당한다.
	
	- #### 왜 __커널 공간__ 을 따로 마련해 놓는가?
		- __커널 코드__ 는 특정한 __커널 공간__ 에만 존재할 수 있다. 그렇지 않고 모든 프로세스 `페이지 테이블`의 공통적인 매핑 정보인 __커널 코드__ 가 여기저기 흩어져 있다면, 매번 모든 프로세스의 `페이지 테이블`을 수정해야 할 것이다. 특정한 __커널 공간__ 에만 존재해야 하는 __커널 코드__ 의 특성상, 커널 공간의 프로세스는 최대한 효율적으로 __커널 공간__ 의 메모리를 할당받아야 한다.
        > 효율적인 메모리 할당을 위해 `슬랩`을 사용할 수 있다.
    
	- #### __커널 공간__ 의 여유 메모리가 부족하다면 어떻게 되는가? 
		- __사용자 공간__ 의 메모리를 빌려와야 한다. 이때 __사용자 공간__ 의 `high memory`에 메모리를 할당받고 할당받은 페이지의 정보를 __커널 공간__ 의 `ZONE_HIGHMEM`구역에 저장하게 된다.
    
    - #### __커널 공간__ 의 메모리 구역     
		- `ZONE_DMA`
            - 16MB 이하의 메모리 공간
			- 가상메모리 서비스를 받지 못하는 `I/O장치`들은 __시스템 버스__ 의 폭에 따라 `주기억장치` 의 모든 공간에 접근하기 어려울 수 있기에 `DMA` 가 접근 가능한 구역을 `ZONE_DMA` 로 정해 놓는다.
        - `ZONE_NORMAL`
            - 16MB ~ 896MB 사이의 메모리 공간
			- 일반적으로 접근 가능한 __커널 공간__ 이며 메모리가 부족하지 않는 한 일반적 할당 작업은 이 구역에서 처리한다.
        - `ZONE_HIGHMEM`
			- 896MB 이상의 메모리 공간
            - 동적으로 __사용자 공간__ 으로부터 할당받은 메모리의 정보를 저장해서 __커널 프로세스__ 가 접근할 수 있게 한다.
        > `ZONE_DMA`와 `ZONE_NORMAL`구역은 __물리 메모리__ 와 1:1로 매핑되는 __논리 주소__ 라고 부르고, `ZONE_HIGHMEM`은 __가상 주소__ 라고 부른다.

- ### `슬랩`이란?
    - 큰 자료구조를 생성하고 해제하는 작업을 자주 실행하는 경우 `슬랩`을 사용하면 효율적으로 메모리를 관리할 수 있다. 
    - `슬랩`을 사용하면 다음과 같은 이점이 있다.
        - `해제 리스트`에 해제된 객체들을 캐시하고, 특정한 자료구조만을 대상으로 할당하고 해제하므로 __성능__ 을 향상시킬 수 있다.
        - 여러 커널 프로세스에서 다양한 크기의 자료구조를 필요할 때마다 할당하는 방식과 비교하여, `슬랩`은 하나의 `슬랩`이 하나의 자료구조만을 다루고 `슬랩`의 크기가 정해져 있으므로 __메모리 단편화__ 를 줄일 수 있다.
        - 프로세서별로 별도의 캐시를 가지고 있는 시스템이라면 락을 사용하지 않고도 `슬랩`에 할당 및 해제가 가능하다.

- ### `CPU`별로 데이터를 사용하면 얻는 이점과 단점에 대해 논하시오.
    - `CPU`별 데이터는 배열에 저장되며 각 항목들이 시스템의 각 프로세서에 대응됨 -> 각 프로세서에서만 사용되는 데이터이므로 락이 필요하지 않다.
    - __이점__
        - 특정 메모리 영역에 있는 데이터를 여러 프로세서가 동시에 캐싱하지 않고 `CPU`별 데이터로 관리한다면 __캐시 스래싱__ 현상을 줄일 수 있다. `리눅스`의 `Private lock variable`이 그 예시이다.
        - 특정 프로세서의 데이터에 다른 프로세서가 접근할 가능성이 없다면 `CPU`별 데이터에 접근할 때 락을 걸지 않아도 된다.

    - __단점__
        - `CPU`별 데이터를 다룰 때 __커널 선점__ 을 막아야 한다. 현재 프로세서 번호를 받고 난 후에는 휴면 상태가 될 수 없다.
        - `CPU`별 데이터에 접근할 때 락을 사용하지 않는다면, 경쟁 조건이 발생할 수 있기때문에 다른 프로세서의 데이터에 접근하는 일은 없어야 한다.

- ### `vmalloc`과 `kmalloc`의 차이를 정리하고, 둘 사이에 성능 차이가 생기는 예시를 하나 드시오.
    - __공통점__
        - 커널 프로세스가 페이지 단위의 큰 메모리가 아닌 그보다 작은 메모리를 할당할 때 주로 사용된다.
        - 연속된 가상 메모리 영역을 할당한다.
    - __차이점__
        - `vmalloc`
            - 할당하는 메모리가 물리적으로 연속하다는 것을 보장할 수 없다.
            - `kmalloc`보다 큰 메모리를 할당할 수 있다.
        - `kmalloc`
            - 물리적으로도 연속된 메모리를 할당한다.
            - 할당할 수 있는 최대 메모리 크기가 정해져 있다.
    - __성능 차이__
        - `vmalloc`이 `kmalloc`보다 성능이 떨어질 수 있다.
            - __이유__
                - `vmalloc`은 물리적으로 연속하는 메모리를 할당하지 않으므로 `kmalloc`에 비해 추가적인 `페이지 테이블` 수정 작업을 거쳐야 한다.
                - `vmalloc`을 사용하면 `페이지 테이블`에 `페이지` 단위로 등록해야 하므로 `kmalloc`을 사용할 때에 비해 `TLB` 접근이 많아진다.
    - __`vmalloc`과 `kmalloc` 사이에 성능 차이가 생기는 예시__
        - `DMA`를 사용할 때
            - `CPU`는 `DMA controller`에게 __시작 주소__ 와 __읽어야 할 데이터의 크기__ 를 넘겨주는데, 이때는 물리적으로 연속한 메모리에 데이터를 저장하는 것이 좋다.