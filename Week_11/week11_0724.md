- ### `mm_struct`와 `vm_area_struct`에 대해 설명하시오.
    - `mm_struct`
        - `mm_struct`는 프로세스의 주소 공간을 표현하는 정보를 담고 있는 구조체이다.
        - 프로세스의 `task_struct`구조체의 `mm`항목이 해당 프로세스의 `mm_struct`구조체를 가리키며 __프로세스 스케줄링__ 발생 시 해당 프로세스의 서술자인 `task_struct`의 `mm`항목이 가리키는 `mm_struct`가 로드된다.
			- __커널 스레드__ 에는 프로세스 주소 공간이 없기 때문에 `mm`항목이 가리키는 `mm_struct` 또한 없다. 하지만 __커널 스레드__ 는 __커널 메모리 영역__ 에 접근하기 위한 `페이지 테이블`과 같이 `mm_struct`구조체의 일부 정보가 필요할 수 있기에 이전 프로세스의 주소 공간을 그대로 둔다.
                - 이전 프로세스의 주소 공간을 그대로 사용하는 것이 어떻게 __커널 스레드__ 가 필요로 하는 정보를 제공할 수 있는 방법이 되는가?
                    > __커널 스레드__ 가 접근하는 메모리 영역은 __커널 메모리 영역__ 인데, 이는 모든 프로세스가 `페이지 테이블` 상에서 공유하는 __메모리 영역__ 이기에 어느 프로세스든 이전에 사용하던 프로세스의 주소 공간을 그대로 사용하면 __커널 스레드__ 가 필요로 하는 __커널 메모리 영역__ 에 대한 정보를 얻을 수 있다.
        
		- `mm_Struct`는 __메모리 영역__ 들로 이루어져 있다.
            - `mm_struct`를 구성하는 __메모리 영역__ 들은 `mmap`과 `mm_rb`의 자료구조에 같은 내용을 담아 유지한다.
                - `mmap`
					__리스트__ 형태로 모든 __메모리 영역__ 을 탐색할 때 유용하다. 연결 형태가 간단하고 __리스트 헤드__ 에서 시작하여 __리스트__ 의 마지막 노드까지 빠르게 순회할 수 있기 때문이다.
                - `mm_rb`
					__레드블랙트리__ 형태로 특정 __메모리 영역__ 을 탐색할 때 유용하다. 균일하고 빠른 탐색 시간(O(log n)) 이 보장되기 때문이다.
					
    - `vm_area_struct`
        - `vm_area_struct`는 주어진 주소 공간에서 연속된 구간에 해당하는 __단일 메모리 영역__ 을 나타낸다.
            - 커널은 각 메모리 영역을 독립적인 메모리 겍체로 간주하기에 각 __메모리 영역__ 은 영역별로 접근 권한 및 관련된 작업들을 설정할 수 있다.
                - 이 덕분에 프로세스 주소 공간의 스택 혹은 데이터 영역, 파일과 매핑된 메모리 영역 등 종류가 다른 __메모리 영역__ 들을 하나의 `vm_area_struct`로 모두 표현할 수 있다.
            - `vm_area_struct`는 해당 __메모리 영역__ 에 대한 정보를 담고 있다.
                - __메모리 영역__ 의 시작과 끝 주소
                    > `[ vm_start, vm_end)`
                - `mm_struct`가 유지하는 `vm_area_struct`의 __리스트__ 를 구현하기 위한 `vm_next` 포인터
                - `mm_struct`가 유지하는 `vm_area_struct`의 __레드블랙트리__ 를 구현하기 위한 `vm_rb` 변수
                - 접근 권한과 플래그
                - `vm_area_struct`가 실행하는 함수들의 포인터들이 존재하는 구조체를 가리키는 포인터 `vm_ops`
                - 등등
        - `mm_struct`는 `vm_area_struct`들의 정보를 유지하고 있다.
		
- ### `VMA 플래그`에 대해 설명하시오.
	- `vm_flags` 항목에 메모리 영역의 동작과 메모리 영역이 들어 있는 페이지에 대한 정보를 제공한다.
		- `VM_READ`, `VM_WRITE`, `VM_EXEC`
		- `VMA`의 종류에 따라 적절하게 조합하여 프로세스의 접근 권한을 제어하는 플래그들이다.
			- __코드 영역__ 이라면 `VM_READ`, `VM_EXEC`
			- __데이터 영역__ 이라면 `VM_READ`, `VM_WRITE`
			- __COPY ON WRITE__ 라면 `VM_READ`
		- `VM_SHARED`
			- 해당 __메모리 영역__ 이 여러 프로세스가 공유하는 영역인지 나타내는 플래그
			- 이 플래그가 설정되어 있으면 __공유 할당__ , 아니면 __개별 할당__ 이라고 부른다.
		- `VM_IO`
			- 해당 __메모리 영역__ 이 장치 입출력 공간으로 할당된 것인지 나타내는 플래그
			- 이 플래그가 설정되어 있는 __메모리 영역__ 은 프로세서의 __코어 덤프__ 에 포함되지 않는다.
				- __코어 덤프__
					- 프로그램 오류 진단 혹은 디버깅에 쓰이기 위해, 프로그램이 비정상적으로 종료되었을 때 만들어지는, 프로세스의 특정 시점의 메모리 상태를 기록한 것
				
- ### `mmap`에 대해 설명하시오.
    - `mmap`
        - `mmap`은 사용자 공간에 제공되는 __시스템 호출__ 이다.
            
            ```c
            #include <sys/mman.h>

            void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);
            /*
            * addr: 매핑할 메모리 주소
            * len: 메모리 공간의 크기
            * prot: 보호모드
            * flags: 매핑된 데이터의 처리 방법을 지정하는 함수
            * fildes: 파일 기술자
            * off: 파일 오프셋
            */
            ```
        - `mmap`은 내부적으로 `do_mmap`을 호출한다.
            - `do_mmap`
                - `do_mmap`은 __커널__ 이 연속된 주소 범위를 새로 만들 때 사용되는 함수이다.
                - `do_mmap`은 새로 생성한 주소 범위와 인접한 주소 범위가 이미 존재하고, 새로 생선한 주소 범위의 권한 설정과 인접한 주소 범위의 그것이 같다면 두 주소 범위를 하나로 합친다.
                > `do_mmap`함수는 프로세스의 주소 공간에 주소 범위를 추가하기 위해 사용하는 함수이다.

- ### `페이지 테이블`을 이용해 가상 주소를 물리 주소로 변환하는 과정에 대해 설명하시오.
    1. `MMU`가 `TLB`에 찾고자 하는 `page offset`이 존재하는지 확인
    2. 존재하면 `TLB`에서 그 정보를 가지고 와서 곧바로 물리 주소로 변환
    3. 존재하지 않으면 메모리에 적재되어 있는 `페이지 테이블`에 접근
        - `PTBR`을 이용하여 현재 프로세스의 `페이지 테이블` 위치를 알 수 있다.
    4. `페이지 테이블`에서 `page offset`에 대응되는 `frame offset` 획득
    5. 가상 주소의 `page offset` 부분을 `frame offset`으로 변환하여 물리 주소 생성
    6. 생성한 물리 주소를 이용하여 메모리로 접근
