 - ### `섹터`와 `블록`에 대해 설명하시오.

- ### `bio`구조체에 대해 설명하시오.
    - `bio`구조체는 커널 내부에서 블록 입출력을 전달하는 기본 장치로 현재 진행 중인 블록 입출력 동작을 `세그먼트`들을 리스트 형태로 관리한다. 
	
	- #### __세그먼트__ 와 __버퍼__
		- `세그먼트`
			- 가상 주소와 물리 주소가 모두 연속적인 `버퍼`
		- `버퍼`
            - 디스크 상의 블록을 메모리 상에 표현하는 객체
			- 각 버퍼마다 `buffer_head` 구조체 서술자를 갖는다.
	
    - 하나의 `세그먼트`는 메모리 상에서 __연속적__ 이지만, `세그먼트`들의 리스트는 그럴 필요가 없다.
        - `bio`구조체는 __scatter-gather__ 를 기능을 지원하여 메모리 상에 연속적이지 않은 메모리 위치로부터 데이터를 전송받거나 메모리 상에 연속적이지 않은 메모리 위치로 데이터를 전송할 수 있다.

- ### `buffer_head`구조체와 `bio`구조체의 차이점을 제시하시오.
    - `buffer_head`
        - 하나의 `버퍼`를 표현하는 구조체
        - 디스크 상의 블록과 메모리 상의 버퍼의 연결 관계를 정의하는 데이터가 담겨 있다.
			
    - `buffer_head` vs `bio`
		- `2.6 커널` 이전에는 입출력 단위로 `buffer_head`를 사용하였다.
        - 기존 `buffer_head`의 문제점
            - 하나의 `버퍼`만을 다루는 `buffer_head`의 특성 상 큰 블록 입출력 요청을 처리할 때 모든 요청을 `버퍼` 단위로 분할해서 처리해야 한다.
                - 요청을 `버퍼` 단위로 처리하는 것은 간단하지 않고 좋은 방법이 아니다.
                - 분할된 `버퍼`마다 하나의 `buffer_head`구조체를 가지므로 메모리를 낭비한다.
        - `buffer_head`의 문제점을 해결한 `bio`
            - `bio`는 `buffer_head`를 __추상화__ 한 것이다.
                - __근거__
                    - 하나의 `버퍼`만을 표현하는 것을 넘어, 앞으로 처리할 `세그먼트`들의 리스트를 유지하는 자료구조이기 때문이다.
                - __추상화__ 의 이점
					- `bio`구조체는 물리적 페이지를 다루므로 상위 메모리를 쉽게 표현할 수 있다.
                    - 여러 물리적 페이지에 걸친 데이터를 처리하는 __scatter-gather__ 기법을 사용할 수 있다.
                    - 기존 `블록`과 `버퍼`의 간단하지 않은 연결 관계를 담느라 무거웠던 `buffer_head`의 한계를 극복하고, 블록 입출력 작업을 처리하는 데 필요한 __최소한의 정보__ 만을 담아 훨씬 가벼워졌다.
    
	- `buffer_head`는 더 이상 사용하지 않는가?
        - `bio`에는 불록 입출력 작업을 처리하기 위한 정보만 담고 있으므로, 개별 `버퍼`에 대한 상태 정보를 가지고 있지 않다.
        - 따라서 개별 `버퍼`의 정보를 담고 있는 `buffer_head`의 역할이 없어진 것은 아니다.
    > `bio`와 `buffer_head`는 서로 자신의 규모를 작게 유지할 수 있는 __공생 관계__ 이다.

- ### `deadline`, `as`, `cfq`, `noop`을 비교하시오.
