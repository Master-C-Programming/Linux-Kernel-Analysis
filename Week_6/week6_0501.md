- ### `스핀락`과 `세마포어`의 특징을 설명하고, `스핀락`과 `세마포어` 각각을 어느 조건 속에서 사용하면 좋은지를 둘의 차이점을 근거로 하여 설명하시오. 

- ### 재귀적인 락은 어떻게 구현되며 언제 사용하는가?

- ### __배리어__ 의 필요성을 설명하고 배리어 함수들의 기능에 대해 논하시오.
    - __배리어__ 의 필요성
        - 컴파일러는 코드 간의 *의존성* 을 기준으로 코드 재배치가 가능한지 판단하고, 이러한 재배치 작업으로 코드를 최적화 할 수 있다. 그러나 코드 간의 의존성이 없다고 하더라도 멀티스레드 환경에서는 코드가 순서대로 실행될 것을 보장해야 할 때가 있다. 이때 __배리어__ 가 필요하다.
    - __배리어__ 함수
        - `rmb()`
            - `rmb()`함수 전후로 읽기 명령이 재배치되는 것을 막는다.
        - `wmb()`
            - `wmb()`함수 전후로 쓰기 명령이 재배치되는 것을 막는다.
        - `mb()`
            - `mb()`함수 전후로 읽기 및 쓰기 명령이 재배치되는 것을 막는다.
        - `read_barrier_depends()`
            - `read_barrier_depends()`함수 전후로 *의존성* 이 있는 읽기 명령이 재배치되는 것을 막는다.
    
- ### 락을 구현할 때 신경써야 할 사항들에는 어떤 것들이 있는지 논하시오.
    - 보호 대상 인식
        - 어떤 데이터가 락을 필요로 하는가?
        - 이 데이터가 전역 데이터인가? 다른 프로세스 또는 스레드에서 접근이 가능한가?
        - 서로 다른 두 인터럽트 핸들러가 해당 데이터를 공유하는가?
        - 프로세스가 데이터를 다루다가 선점 당하고, 선점한 프로세스가 같은 데이터에 접근할 가능성이 있는가?
        - 현재 실행 중인 프로세스가 휴면 상태로 전환될 수 있는가? 그렇다면 공유 데이터는 어떤 상태가 되는가?
        - 이 데이터 또는 코드가 동시성에 대해 안전한가? 어떻게 그 사실을 확신할 수 있는가?
    - 얼마나 세세하게 락을 구현해야 하는가?
        - 경쟁과 확장성
            - 경쟁
                - 락이 세분화되어있지 않다면 임계 구역의 한 지점에 접근할 때도 임계 구역 전체에 락을 걸게 된다. 이렇게 되면 프로세스 간 락을 얻기 위한 경쟁이 심해지고, 이는 시스템 병목의 원인이 된다.
            - 확장성
                - 락이 세분화되어 있다면 경쟁으로 인한 시스템 병목 현상이 줄어들어 확장성에 도움을 줄 수 있다. 그러나 너무 세분화된 락은 작은 시스템에서는 불필요한 오버헤드가 될 수 있다. 따라서 확장성과 성능 사이의 균형이 중요하다.
        > 간단하게 시작하고 필요한 경우에만 복잡도를 높이도록 하자. __단순함이 핵심이다.__